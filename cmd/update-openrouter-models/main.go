// SPDX-FileCopyrightText: 2025 Mads R. Havmand <mads@v42.dk>
//
// SPDX-License-Identifier: AGPL-3.0-only

package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"slices"
	"strconv"
	"strings"

	"codeberg.org/gai-org/gai"
)

type OpenRouterResponse struct {
	Data []struct {
		ID            string `json:"id"`
		CanonicalSlug string `json:"canonical_slug"`
		HuggingFaceID string `json:"hugging_face_id"`
		Name          string `json:"name"`
		Created       int64  `json:"created"`
		Description   string `json:"description"`
		ContextLength int    `json:"context_length"`
		Architecture  struct {
			Modality         string   `json:"modality"`
			InputModalities  []string `json:"input_modalities"`
			OutputModalities []string `json:"output_modalities"`
			Tokenizer        string   `json:"tokenizer"`
			InstructType     *string  `json:"instruct_type"`
		} `json:"architecture"`
		Pricing struct {
			Prompt            string `json:"prompt"`
			Completion        string `json:"completion"`
			Request           string `json:"request"`
			Image             string `json:"image"`
			WebSearch         string `json:"web_search"`
			InternalReasoning string `json:"internal_reasoning"`
		} `json:"pricing"`
		TopProvider struct {
			ContextLength       int  `json:"context_length"`
			MaxCompletionTokens *int `json:"max_completion_tokens"`
			IsModerated         bool `json:"is_moderated"`
		} `json:"top_provider"`
		PerRequestLimits    any      `json:"per_request_limits"`
		SupportedParameters []string `json:"supported_parameters"`
	} `json:"data"`
}

func main() {
	// Fetch data from OpenRouter API
	resp, err := http.Get("https://openrouter.ai/api/v1/models")
	if err != nil {
		log.Fatal("Failed to fetch OpenRouter models:", err)
	}
	defer func() {
		if err := resp.Body.Close(); err != nil {
			log.Printf("Failed to close response body: %v", err)
		}
	}()

	var openRouterResp OpenRouterResponse
	if err := json.NewDecoder(resp.Body).Decode(&openRouterResp); err != nil {
		log.Fatal("Failed to decode response:", err)
	}

	// Convert to our model format
	models := make(map[string]gai.Model)
	seen := make(map[string]bool)

	for _, model := range openRouterResp.Data {
		if model.ID == "" || seen[model.ID] {
			continue
		}
		seen[model.ID] = true

		// Parse pricing
		inputPrice := parsePrice(model.Pricing.Prompt)
		outputPrice := parsePrice(model.Pricing.Completion)

		// Determine capabilities
		supportsVision := contains(model.Architecture.InputModalities, "image")
		supportsJSON := contains(model.SupportedParameters, "response_format") ||
			contains(model.SupportedParameters, "json_schema") // Check for JSON support
		supportsTools := contains(model.SupportedParameters, "tools") ||
			contains(model.SupportedParameters, "tool_choice") // Check for tools support
		supportsStreaming := contains(model.SupportedParameters, "stream") // Check for streaming support
		supportsReasoning := contains(model.SupportedParameters, "reasoning")

		// Use top provider context length if available, otherwise model context length
		maxInputTokens := model.ContextLength
		if model.TopProvider.ContextLength > 0 {
			maxInputTokens = model.TopProvider.ContextLength
		}

		// Use max completion tokens from top provider if available
		maxOutputTokens := 0
		if model.TopProvider.MaxCompletionTokens != nil {
			maxOutputTokens = *model.TopProvider.MaxCompletionTokens
		}
		if maxOutputTokens <= 0 {
			// Estimate max output tokens (typically 1/4 of input for most models)
			maxOutputTokens = max(min(maxInputTokens/4, 16384), 1024) // Cap at reasonable limit with minimum
		}

		models[model.ID] = gai.Model{
			ID:       model.ID,
			Name:     model.Name,
			Provider: "openrouter", // Will be replaced with PROVIDER_ID_OPENROUTER constant
			Pricing: gai.ModelPricing{
				InputTokenPrice:  inputPrice,
				OutputTokenPrice: outputPrice,
			},
			Capabilities: gai.ModelCapabilities{
				SupportsStreaming: supportsStreaming,
				SupportsJSON:      supportsJSON,
				SupportsTools:     supportsTools,
				SupportsVision:    supportsVision,
				SupportsReasoning: supportsReasoning,
				MaxInputTokens:    maxInputTokens,
				MaxOutputTokens:   maxOutputTokens,
			},
		}
	}

	// Write to Go file
	file, err := os.Create("internal/models/openrouter_models.gen.go")
	if err != nil {
		log.Fatal("Failed to create output file:", err)
	}
	defer func() {
		if err := file.Close(); err != nil {
			log.Printf("Failed to close file: %v", err)
		}
	}()

	// Write header and package declaration
	if _, err := fmt.Fprint(file, `// SPDX-FileCopyrightText: 2025 Mads R. Havmand <mads@v42.dk>
//
// SPDX-License-Identifier: AGPL-3.0-only

// Code generated by cmd/update-openrouter-models/main.go. DO NOT EDIT.

package models

import (
	"codeberg.org/gai-org/gai"
)

var openRouterModelsGenerated = map[string]gai.Model{
`); err != nil {
		log.Fatal("Failed to write header:", err)
	}

	for id, model := range models {
		if _, err := fmt.Fprintf(file, "\t\"%s\": {\n", id); err != nil {
			log.Fatal("Failed to write model entry:", err)
		}
		if _, err := fmt.Fprintf(file, "\t\tID:       \"%s\",\n", model.ID); err != nil {
			log.Fatal("Failed to write model ID:", err)
		}
		if _, err := fmt.Fprintf(file, "\t\tName:     \"%s\",\n", escapeString(model.Name)); err != nil {
			log.Fatal("Failed to write model name:", err)
		}
		if _, err := fmt.Fprintf(file, "\t\tProvider: PROVIDER_ID_OPENROUTER,\n"); err != nil {
			log.Fatal("Failed to write provider:", err)
		}
		if _, err := fmt.Fprintf(file, "\t\tPricing: gai.ModelPricing{\n"); err != nil {
			log.Fatal("Failed to write pricing struct:", err)
		}
		if _, err := fmt.Fprintf(file, "\t\t\tInputTokenPrice:  %g,\n", model.Pricing.InputTokenPrice); err != nil {
			log.Fatal("Failed to write input token price:", err)
		}
		if _, err := fmt.Fprintf(file, "\t\t\tOutputTokenPrice: %g,\n", model.Pricing.OutputTokenPrice); err != nil {
			log.Fatal("Failed to write output token price:", err)
		}
		if _, err := fmt.Fprintf(file, "\t\t},\n"); err != nil {
			log.Fatal("Failed to write pricing close:", err)
		}
		if _, err := fmt.Fprintf(file, "\t\tCapabilities: gai.ModelCapabilities{\n"); err != nil {
			log.Fatal("Failed to write capabilities struct:", err)
		}
		if _, err := fmt.Fprintf(file, "\t\t\tSupportsStreaming: %t,\n", model.Capabilities.SupportsStreaming); err != nil {
			log.Fatal("Failed to write streaming support:", err)
		}
		if _, err := fmt.Fprintf(file, "\t\t\tSupportsJSON:      %t,\n", model.Capabilities.SupportsJSON); err != nil {
			log.Fatal("Failed to write JSON support:", err)
		}
		if _, err := fmt.Fprintf(file, "\t\t\tSupportsTools:     %t,\n", model.Capabilities.SupportsTools); err != nil {
			log.Fatal("Failed to write tools support:", err)
		}
		if _, err := fmt.Fprintf(file, "\t\t\tSupportsVision:    %t,\n", model.Capabilities.SupportsVision); err != nil {
			log.Fatal("Failed to write vision support:", err)
		}
		if _, err := fmt.Fprintf(file, "\t\t\tSupportsReasoning: %t,\n", model.Capabilities.SupportsReasoning); err != nil {
			log.Fatal("Failed to write reasoning support:", err)
		}
		if _, err := fmt.Fprintf(file, "\t\t\tMaxInputTokens:    %d,\n", model.Capabilities.MaxInputTokens); err != nil {
			log.Fatal("Failed to write max input tokens:", err)
		}
		if _, err := fmt.Fprintf(file, "\t\t\tMaxOutputTokens:   %d,\n", model.Capabilities.MaxOutputTokens); err != nil {
			log.Fatal("Failed to write max output tokens:", err)
		}
		if _, err := fmt.Fprintf(file, "\t\t},\n"); err != nil {
			log.Fatal("Failed to write capabilities close:", err)
		}
		if _, err := fmt.Fprintf(file, "\t},\n"); err != nil {
			log.Fatal("Failed to write model close:", err)
		}
	}

	if _, err := fmt.Fprint(file, "}\n"); err != nil {
		log.Fatal("Failed to write closing brace:", err)
	}

	log.Printf("Generated openrouter_models.gen.go with %d unique models out of %d total", len(models), len(openRouterResp.Data))
}

func parsePrice(priceStr string) float64 {
	if priceStr == "" || priceStr == "0" {
		return 0.0
	}

	price, err := strconv.ParseFloat(priceStr, 64)
	if err != nil {
		return 0.0
	}

	// Store price as-is (per million tokens from OpenRouter API)
	return price
}

func contains(slice []string, item string) bool {
	return slices.Contains(slice, item)
}

func escapeString(s string) string {
	return strings.ReplaceAll(s, "\"", "\\\"")
}
